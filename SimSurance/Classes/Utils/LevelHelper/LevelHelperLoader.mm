//  This file was generated by LevelHelper
//  http://levelhelper.wordpress.com
//
//  LevelHelperLoader.mm - online version
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////

#import "LevelHelperLoader.h"

/// converts degrees to radians
#define DEGREES_TO_RADIANS(__ANGLE__) ((__ANGLE__) / 180.0f * (float)M_PI)
/// converts radians to degrees
#define RADIANS_TO_DEGREES(__ANGLE__) ((__ANGLE__) / (float)M_PI * 180.0f)

#if TARGET_OS_EMBEDDED || TARGET_OS_IPHONE || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64

#define LHRectFromString(str) CGRectFromString(str)
#define LHPointFromString(str) CGPointFromString(str)
#else
#define LHRectFromString(str) NSRectToCGRect(NSRectFromString(str))
#define LHPointFromString(str) NSPointToCGPoint(NSPointFromString(str))
#endif


enum LH_JOINT_TYPE
{
	LH_DISTANCE_JOINT = 0,
	LH_REVOLUTE_JOINT,
	LH_PRISMATIC_JOINT,
	LH_PULLEY_JOINT,
	LH_GEAR_JOINT,
	LH_LINE_JOINT,
	LH_WELD_JOINT
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
@interface LevelHelperLoader (Private)

-(void) initObjects;

-(void) addBatchNodesToLayer:(CCLayer*)cocosLayer;

-(void) setFixtureDefPropertiesFromDictionary:(NSDictionary*)spritePhysic 
									  fixture:(b2FixtureDef*)shapeDef;

-(b2Body*) b2BodyFromDictionary:(NSDictionary*)spritePhysic
			   spriteProperties:(NSDictionary*)spriteProp
						   data:(CCSprite*)ccsprite 
						  world:(b2World*)world;

-(b2Joint*) b2JointFromDictionary:(NSDictionary*)dictionary 
								world:(b2World*)world;

-(void)loadLevelHelperSceneFile:(NSString*)levelFile 
					inDirectory:(NSString*)subfolder
				   imgSubfolder:(NSString*)imgFolder;
@end

@implementation LevelHelperLoader
////////////////////////////////////////////////////////////////////////////////////
-(void) initObjects
{
	batchNodes = [[NSMutableDictionary alloc] init];	
	ccSpritesInScene = [[NSMutableDictionary alloc] init];
	noPhysicSprites = [[NSMutableDictionary alloc] init];
	ccJointsInScene = [[NSMutableDictionary alloc] init];
	
	addSpritesToLayerWasUsed = false;
	addObjectsToWordWasUsed = false;
	
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
-(id) initWithContentOfFile:(NSString*)levelFile
{
	NSAssert(nil!=levelFile, @"Invalid file given to LevelHelperLoader");
	
	if(!(self = [super init]))
	{
		NSLog(@"LevelHelperLoader ****ERROR**** : [super init] failer ***");
		return self;
	}
	
	[self initObjects];
	[self loadLevelHelperSceneFile:levelFile inDirectory:@"" imgSubfolder:@""];
	
	
	return self;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
-(id) initWithContentOfFile:(NSString*)levelFile 
			 levelSubfolder:(NSString*)levelFolder 
			imagesSubfolder:(NSString*)imgFolder
{
	NSAssert(nil!=levelFile, @"Invalid file given to LevelHelperLoader");
	
	if(!(self = [super init]))
	{
		NSLog(@"LevelHelperLoader ****ERROR**** : [super init] failer ***");
		return self;
	}
	
	[self initObjects];
	
	[self loadLevelHelperSceneFile:levelFile inDirectory:levelFolder imgSubfolder:imgFolder];
	
	return self;
	
}
////////////////////////////////////////////////////////////////////////////////////
+(id)LevelHelperLoaderWithContentOfFile:(NSString*)levelFile
{
	return [[[self alloc] initWithContentOfFile:levelFile] autorelease];
}

+(id) LevelHelperLoaderWithContentOfFile:(NSString*)levelFile 
						  levelSubfolder:(NSString*)levelFolder 
						 imagesSubfolder:(NSString*)imgFolder
{
	return [[[self alloc] initWithContentOfFile:levelFile 
								 levelSubfolder:levelFolder 
								imagesSubfolder:imgFolder] autorelease];
}
////////////////////////////////////////////////////////////////////////////////////
-(void) addObjectsToWorld:(b2World*)world 
			 cocos2dLayer:(CCLayer*)_cocosLayer
{
	
	NSAssert(addSpritesToLayerWasUsed!=true, @"You can't use method addObjectsToWorld because you already used addSpritesToLayer. Only one of the two can be used."); 
	NSAssert(addObjectsToWordWasUsed!=true, @"You can't use method addObjectsToWorld again. You can only use it once. Create a new LevelHelperLoader object if you want to load the level again."); 
	
	addObjectsToWordWasUsed = true;
	
	cocosLayer = _cocosLayer;
	
	[self addBatchNodesToLayer:cocosLayer];
	
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		NSDictionary* physicProp = [dictionary objectForKey:@"PhysicProperties"];
		
		//find the coresponding batch node for this sprite
		NSDictionary* batchInfo = [batchNodes objectForKey:[spriteProp objectForKey:@"Image"]];
		CCSpriteBatchNode *batch = [batchInfo objectForKey:@"CCBatchNode"];
		
		if(nil != batch)
		{
			CCSprite* ccsprite = [self spriteWithBatchFromDictionary:spriteProp batchNode:batch];
			[batch addChild:ccsprite z:[[spriteProp objectForKey:@"ZOrder"] intValue]];
			
			NSString* uniqueName = [spriteProp objectForKey:@"UniqueName"];
			if([[physicProp objectForKey:@"Type"] intValue] != 3) //3 means no physic
			{
				b2Body* body = [self b2BodyFromDictionary:physicProp
										 spriteProperties:spriteProp
													 data:ccsprite 
													world:world];
				NSValue *value = [NSValue valueWithPointer:body];
				[ccSpritesInScene setObject:value forKey:uniqueName];			
			}
			else {
				[noPhysicSprites setObject:ccsprite forKey:uniqueName];
			}
		}
	}
	
	for(NSDictionary* jointDict in lhJoints)
	{
		b2Joint* boxJoint = [self b2JointFromDictionary:jointDict world:world];
		
		if(nil != boxJoint){
			[ccJointsInScene setObject:[NSValue valueWithPointer:boxJoint] 
								forKey:[jointDict objectForKey:@"UniqueName"]];	
		}
	}	
}
////////////////////////////////////////////////////////////////////////////////////
-(void) addSpritesToLayer:(CCLayer*)_cocosLayer
{	
	NSAssert(addObjectsToWordWasUsed!=true, @"You can't use method addSpritesToLayer because you already used addObjectToWorld. Only one of the two can be used."); 
	NSAssert(addSpritesToLayerWasUsed!=true, @"You can't use method addSpritesToLayer again. You can only use it once. Create a new LevelHelperLoader object if you want to load the level again."); 
	
	addSpritesToLayerWasUsed = true;
	
	cocosLayer = _cocosLayer;
	
	[self addBatchNodesToLayer:cocosLayer];
	
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		
		//find the coresponding batch node for this sprite
		NSDictionary* batchInfo = [batchNodes objectForKey:[spriteProp objectForKey:@"Image"]];
		CCSpriteBatchNode *batch = [batchInfo objectForKey:@"CCBatchNode"];
		
		if(nil != batch)
		{
			CCSprite* ccsprite = [self spriteWithBatchFromDictionary:spriteProp batchNode:batch];
			if(nil != ccsprite)
			{
				[batch addChild:ccsprite];
				[ccSpritesInScene setObject:ccsprite forKey:[spriteProp objectForKey:@"UniqueName"]];
			}
		}
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
-(bool) hasWorldBoundaries
{
	if(worldBoundaries.origin.x == 0.0f && 
	   worldBoundaries.origin.x == 0.0f &&
	   worldBoundaries.size.width == 0.0f &&
	   worldBoundaries.size.height== 0.0f)
	{
		return false;
	}
	
	return true;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
-(void) createWorldBoundaries:(b2World*)_world
{
	NSAssert(worldBoundaries.size.width != 0, @"You can't use method createWorldBoundaries because you have not defined any world boundaries inside LevelHelper."); 
	
	// Define the ground body.
	b2BodyDef groundBodyDef;
	groundBodyDef.position.Set(0,0); // bottom-left corner
	
	// Call the body factory which allocates memory for the ground body
	// from a pool and creates the ground box shape (also from a pool).
	// The body is also added to the world.
	b2Body* groundBody = _world->CreateBody(&groundBodyDef);
	
	// Define the ground box shape.
	b2PolygonShape groundBox;		
	
	CGSize ss = [CCDirector sharedDirector].winSize;
	// bottom
	groundBox.SetAsEdge(b2Vec2(worldBoundaries.origin.x/PTM_RATIO, (ss.height - (worldBoundaries.origin.y + worldBoundaries.size.height))/PTM_RATIO), 
						b2Vec2((worldBoundaries.origin.x+ worldBoundaries.size.width)/PTM_RATIO, (ss.height - (worldBoundaries.origin.y + worldBoundaries.size.height))/PTM_RATIO));
	groundBody->CreateFixture(&groundBox,0);
	
	// top
	groundBox.SetAsEdge(b2Vec2(worldBoundaries.origin.x/PTM_RATIO, (ss.height - worldBoundaries.origin.y)/PTM_RATIO), 
						b2Vec2((worldBoundaries.origin.x + worldBoundaries.size.width)/PTM_RATIO, (ss.height - worldBoundaries.origin.y)/PTM_RATIO));
	groundBody->CreateFixture(&groundBox,0);
	
	// left
	groundBox.SetAsEdge(b2Vec2(worldBoundaries.origin.x/PTM_RATIO, (ss.height - (worldBoundaries.origin.y + worldBoundaries.size.height))/PTM_RATIO), 
						b2Vec2(worldBoundaries.origin.x/PTM_RATIO, (ss.height - worldBoundaries.origin.y)/PTM_RATIO));
	groundBody->CreateFixture(&groundBox,0);
	
	// right
	groundBox.SetAsEdge(b2Vec2((worldBoundaries.origin.x + worldBoundaries.size.width)/PTM_RATIO, (ss.height - (worldBoundaries.origin.y + worldBoundaries.size.height))/PTM_RATIO),
						b2Vec2((worldBoundaries.origin.x + worldBoundaries.size.width)/PTM_RATIO, (ss.height - worldBoundaries.origin.y)/PTM_RATIO));
	groundBody->CreateFixture(&groundBox,0);
	
	
}
////////////////////////////////////////////////////////////////////////////////////
-(unsigned int) numberOfBatchNodesUsed
{
	return (int)[batchNodes count] -1;
}
////////////////////////////////////////////////////////////////////////////////////
-(bool) isSpriteWithUniqueName:(NSString*)name atPoint:(CGPoint)point
{
    CCSprite* sprite = [self spriteWithUniqueName:name];
    
    if(nil == sprite)
        return false;
    
    CGPoint position = [sprite position];
    CGSize size = [sprite contentSize];
    
    if((point.x > position.x - size.width/2) &&
       (point.x < position.x + size.width/2) &&
       (point.y > position.y - size.height/2) &&
       (point.y < position.y + size.height/2))
        return true;
    
    return false;
}
////////////////////////////////////////////////////////////////////////////////////
-(CCSprite*) spriteWithUniqueName:(NSString*)name
{
	if(addSpritesToLayerWasUsed)
	{
		return [ccSpritesInScene objectForKey:name];	
	}
	else if(addObjectsToWordWasUsed)
	{
		b2Body* body = (b2Body*)[[ccSpritesInScene objectForKey:name] pointerValue];
		
		if(nil != body)
			return (CCSprite*)body->GetUserData();
		else {
			CCSprite* sprite = (CCSprite*)[noPhysicSprites objectForKey:name];
			
			return sprite;
		}
		
	}
	
	return nil;
}
////////////////////////////////////////////////////////////////////////////////////
-(b2Body*) bodyWithUniqueName:(NSString*)name
{
	if(addObjectsToWordWasUsed)
	{
		b2Body* body = (b2Body*)[[ccSpritesInScene objectForKey:name] pointerValue];
		
		return body;
	}
	
	return nil;
}
////////////////////////////////////////////////////////////////////////////////////
-(bool) removeSpriteWithUniqueName:(NSString*)name
{
	//NSAssert(addObjectsToWordWasUsed!=true, @"You cannot remove a sprite with method removeCCSpriteWithUniqueName if you used the method addObjectToWorld to load your level. Use method removeBody."); 
	
	CCSprite* ccsprite = nil;
	if(!addObjectsToWordWasUsed)
	{
		ccsprite = [ccSpritesInScene objectForKey:name];
	}
	else {
		ccsprite = [noPhysicSprites objectForKey:name];
	}
	if(nil == ccsprite)
	{
		return false;
	}
	
	if([ccsprite usesBatchNode])
	{
		CCSpriteBatchNode *batchNode = [ccsprite batchNode];
		
		[batchNode removeChild:ccsprite cleanup:YES];
	}
	else {
		NSLog(@"This CCSprite was not created using a batch node so it's your responsibility to remove it.");
		return false;
	}
	
	
	if(!addObjectsToWordWasUsed)
	{
		[ccSpritesInScene removeObjectForKey:name];
	}
	else {
		[noPhysicSprites removeObjectForKey:name];
	}
	
	
	return true;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
-(bool) removeSprite:(CCSprite*)ccsprite
{
	//NSAssert(addObjectsToWordWasUsed!=true, @"You cannot remove a sprite with method removeCCSprite if you used the method addObjectToWorld to load your level. Use method removeBody."); 
	
	if(nil == ccsprite)
		return false;
	
	if([ccsprite usesBatchNode])
	{
		NSArray * keys= nil;
		if(!addObjectsToWordWasUsed)
			keys = [ccSpritesInScene allKeysForObject:ccsprite];
		else {
			keys = [noPhysicSprites allKeysForObject:ccsprite];
		}
		
		CCSpriteBatchNode *batchNode = [ccsprite batchNode];
		
		[batchNode removeChild:ccsprite cleanup:YES];
		
		for(NSString* key in keys)
		{
			if(!addObjectsToWordWasUsed)
				[ccSpritesInScene removeObjectForKey:key];
			else {
				[noPhysicSprites removeObjectForKey:key];
			}
			
		}
	}
	else 
	{
		NSLog(@"This CCSprite was not created using a batch node so it's your responsibility to remove it.");
		return false;
	}
	
	return true;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
-(bool) removeAllSprites
{	
	//NSAssert(addObjectsToWordWasUsed!=true, @"You cannot remove all sprites with method removeAllCCSprites if you used the method addObjectToWorld to load your level. Use method removeAllBodies."); 
	
	NSArray *keys = nil;
	if(!addObjectsToWordWasUsed)
		keys = [ccSpritesInScene allKeys];
	else {
		keys = [noPhysicSprites allKeys];
	}
	
	bool removedAll = true;
	for(NSString* key in keys)
	{
		removedAll = removedAll == [self removeSpriteWithUniqueName:key];
	}
	
	return removedAll;	
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
-(void) removeFromBatchNode:(CCSprite*)sprite
{
	CCSpriteBatchNode *batchNode = [sprite batchNode];
	
	if(nil == batchNode)
		return;
	
	[batchNode removeChild:sprite cleanup:YES];
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
-(bool) removeBodyWithUniqueName:(NSString*)name
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove a body with method removeBodyWithUniqueName if you used the method addSpritesToLayer to load your level. Use method removeCCSprite or removeCCSpriteWithUniqueName."); 
	
	b2Body* body = (b2Body*)[[ccSpritesInScene objectForKey:name] pointerValue];
	
	if(0 != body)
	{
		return [self removeBody:body];
	}
	
	return false;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
-(bool) removeBody:(b2Body*)body
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove a body with method removeBody if you used the method addSpritesToLayer to load your level. Use method removeCCSprite or removeCCSpriteWithUniqueName."); 
	
	if(0 == body)
		return false;
	
	CCSprite *ccsprite = (CCSprite*)body->GetUserData();
	
	if(nil == ccsprite)
		return false;
	
	if([ccsprite usesBatchNode])
	{
		NSArray * keys = [ccSpritesInScene allKeysForObject:[NSValue valueWithPointer:body]];
		
		CCSpriteBatchNode *batchNode = [ccsprite batchNode];
		
		if(nil == batchNode)
			return false;
		
		b2World* _world = body->GetWorld();
		
		if(0 == _world)
			return false;
		
		[batchNode removeChild:ccsprite cleanup:YES];
		
		for(NSString* key in keys)
		{
			[ccSpritesInScene removeObjectForKey:key];
		}
		
		_world->DestroyBody(body);
	}
	else 
	{
		NSLog(@"This b2Body was not created using a addObjectToWorld so it's your responsibility to remove it.");
		return false;
	}
	
	return true;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
-(bool) removeAllBodies
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove all bodies with method removeAllBodies if you used the method addSpritesToLayer to load your level. Use method removeAllCCSprites."); 
	
	NSArray *keys = [ccSpritesInScene allKeys];
	
	bool removedAll = true;
	for(NSString* key in keys)
	{
		removedAll = removedAll == [self removeBodyWithUniqueName:key];
	}
	return removedAll;		
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
-(b2Joint*) jointWithUniqueName:(NSString*)name
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove a joint with method removeJointWithUniqueName if you used the method addSpritesToLayer to load your level."); 
	
	
	b2Joint* joint = (b2Joint*)[[ccJointsInScene objectForKey:name] pointerValue];
	
	return joint;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
-(bool) removeJointWithUniqueName:(NSString*)name
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove a joint with method removeJointWithUniqueName if you used the method addSpritesToLayer to load your level."); 
	
	
	b2Joint* joint = (b2Joint*)[[ccJointsInScene objectForKey:name] pointerValue];
	
	if(0 != joint)
	{
		return [self removeJoint:joint];
	}
	
	return false;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
-(bool) removeAllJoints
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove joints with method removeAllJoints if you used the method addSpritesToLayer to load your level."); 

	NSArray *keys = [ccJointsInScene allKeys];
	
	bool removedAll = true;
	for(NSString* key in keys)
	{
		removedAll = removedAll == [self removeJointWithUniqueName:key];
	}
	return removedAll;	
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
-(bool) removeJoint:(b2Joint*) joint
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot remove a joint with method removeJoint if you used the method addSpritesToLayer to load your level."); 
	
	if(0 == joint)
		return false;
	
	b2Body *body = joint->GetBodyA();
	
	if(0 == body)
	{
		body = joint->GetBodyB();
		
		if(0 == body)
			return false;
	}
	
	NSArray * keys = [ccJointsInScene allKeysForObject:[NSValue valueWithPointer:joint]];
	
	b2World* _world = body->GetWorld();
	
	if(0 == _world)
		return false;
	
	for(NSString* key in keys)
	{
		[ccJointsInScene removeObjectForKey:key];
	}
	_world->DestroyJoint(joint);
	
	
	return true;
}
////////////////////////////////////////////////////////////////////////////////////
-(CCSprite*) newSpriteWithUniqueName:(NSString*)uniqueName 
						  cocos2dLayer:(CCLayer*)_cocosLayer
{
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		
		if([[spriteProp objectForKey:@"UniqueName"] isEqualToString:uniqueName])
		{
			CCSprite* ccsprite = [self spriteFromDictionary:spriteProp];
			
			if(nil != ccsprite)
				[_cocosLayer addChild:ccsprite];
			
			return ccsprite;
		}
	}
	return nil;
}
////////////////////////////////////////////////////////////////////////////////////
-(b2Body*) newBodyWithUniqueName:(NSString*)uniqueName 
						   world:(b2World*)_world
					cocos2dLayer:(CCLayer*)_cocosLayer
{
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		
		if([[spriteProp objectForKey:@"UniqueName"] isEqualToString:uniqueName])
		{
			CCSprite* ccsprite = [self spriteFromDictionary:spriteProp];	
			
			if(nil == ccsprite)
				return 0;
			
			[_cocosLayer addChild:ccsprite];
			
			NSDictionary* physicProp = [dictionary objectForKey:@"PhysicProperties"];
			
			return [self b2BodyFromDictionary:physicProp
							 spriteProperties:spriteProp
										 data:ccsprite 
										world:_world];
		}
	}
	
	return 0;
}
////////////////////////////////////////////////////////////////////////////////////
-(NSMutableArray*)spritesWithTag:(LevelHelper_TAG)tag
{
	NSMutableArray* array = [[[NSMutableArray alloc] init] autorelease];
	
	NSArray *keys = [ccSpritesInScene allKeys];
	for(NSString* key in keys)
	{
		CCSprite* ccSprite = nil;
		
		if(addSpritesToLayerWasUsed)
		{
			ccSprite = [ccSpritesInScene objectForKey:key];
		}
		else 
		{
			b2Body* body = (b2Body*)[[ccSpritesInScene objectForKey:key] pointerValue];
			if(0 != body)
				ccSprite = (CCSprite*)body->GetUserData();
			else {
				ccSprite = [noPhysicSprites objectForKey:key];
			}
			
		}
		
		if(nil != ccSprite && [ccSprite tag] == (int)tag)
		{
			[array addObject:ccSprite];
		}
	}
	
	return array;
}
////////////////////////////////////////////////////////////////////////////////////
-(NSMutableArray*) bodiesWithTag:(LevelHelper_TAG)tag
{
	NSAssert(addSpritesToLayerWasUsed!=true, @"You cannot use method BodiesWithTag if you used the method addSpritesToLayer to load your level."); 
	
	NSMutableArray* array = [[[NSMutableArray alloc] init] autorelease];
	
	NSArray *keys = [ccSpritesInScene allKeys];
	for(NSString* key in keys)
	{
		b2Body* body = (b2Body*)[[ccSpritesInScene objectForKey:key] pointerValue];
		CCSprite* ccSprite = (CCSprite*)body->GetUserData();
		
		if(nil != ccSprite && [ccSprite tag] == (int)tag)
		{
			[array addObject:[NSValue valueWithPointer:body]];
		}
	}
	
	return array;
}
////////////////////////////////////////////////////////////////////////////////////
-(NSMutableArray*)newSpritesWithTag:(LevelHelper_TAG)tag
						 cocos2dLayer:(CCLayer*)_cocosLayer
{
	NSMutableArray* array = [[[NSMutableArray alloc] init] autorelease];
	
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		
		if((LevelHelper_TAG)[[spriteProp objectForKey:@"Tag"] intValue] == tag)
		{
			CCSprite* ccsprite = [self spriteFromDictionary:spriteProp];
			
			if(nil != ccsprite)
			{
				[array addObject:ccsprite];
				[_cocosLayer addChild:ccsprite];
			}
		}
	}
	
	return array;
}
////////////////////////////////////////////////////////////////////////////////////
-(NSMutableArray*) newBodiesWithTag:(LevelHelper_TAG)tag 
							  world:(b2World*)_world
					   cocos2dLayer:(CCLayer*)_cocosLayer
{
	NSMutableArray* array = [[[NSMutableArray alloc] init] autorelease];
	
	for(NSDictionary* dictionary in lhSprites)
	{
		NSDictionary* spriteProp = [dictionary objectForKey:@"GeneralProperties"];
		
		if((LevelHelper_TAG)[[spriteProp objectForKey:@"Tag"] intValue] == tag)
		{
			CCSprite* ccsprite = [self spriteFromDictionary:spriteProp];
			
			if(nil != ccsprite)
			{
				NSDictionary* physicProp = [dictionary objectForKey:@"PhysicProperties"];
				
				NSValue* v = [NSValue valueWithPointer:[self b2BodyFromDictionary:physicProp
																 spriteProperties:spriteProp
																			 data:ccsprite 
																			world:_world]];
				
				
				
				[array addObject:v];
				
				[_cocosLayer addChild:ccsprite];
			}
		}
	}
	return array;
}
////////////////////////////////////////////////////////////////////////////////////
-(void) releaseAll
{
	[lhSprites release];
	[lhJoints release];
	
	if(addObjectsToWordWasUsed){
		[self removeAllJoints];	
		[self removeAllBodies];
		[self removeAllSprites]; //for no physic sprites
	}
	else {
		[self removeAllSprites];
	}
	[ccSpritesInScene release];
	[ccJointsInScene release];
	[noPhysicSprites release];
	
	
	NSArray *keys = [batchNodes allKeys];
	for(NSString* key in keys)
	{
		NSDictionary* info = [batchNodes objectForKey:key];
		
		CCSpriteBatchNode *v = [info objectForKey:@"CCBatchNode"];
		[cocosLayer removeChild:v cleanup:true];
	}
	[batchNodes release];
}
////////////////////////////////////////////////////////////////////////////////////
-(void) release
{
	[self releaseAll];
}
///////////////////////////PRIVATE METHODS//////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
-(void) addBatchNodesToLayer:(CCLayer*)_cocosLayer
{
	NSArray *keys = [batchNodes allKeys];
	int tag = 0;
	for(NSString* key in keys)
	{
		NSDictionary* info = [batchNodes objectForKey:key];
		
		CCSpriteBatchNode *v = [info objectForKey:@"CCBatchNode"];
		int z = [[info objectForKey:@"OrderZ"] intValue];
		[_cocosLayer addChild:v z:z tag:tag];
		tag++;
	}
}
////////////////////////////////////////////////////////////////////////////////////
-(CCSprite*) spriteFromDictionary:(NSDictionary*)spriteProp
{
    NSLog(@"spriteWithDict normal");
	CCSprite *ccsprite = [CCSprite spriteWithFile:[spriteProp objectForKey:@"Image"] 
											 rect:LHRectFromString([spriteProp objectForKey:@"UV"])];
	
	[self setSpriteProperties:ccsprite spriteProperties:spriteProp];
	
	return ccsprite;
}
////////////////////////////////////////////////////////////////////////////////////
-(CCSprite*) spriteWithBatchFromDictionary:(NSDictionary*)spriteProp 
								   batchNode:(CCSpriteBatchNode*)batch
{
    NSLog(@"spriteWithBatch normal");
	CCSprite *ccsprite = [CCSprite spriteWithBatchNode:batch 
												  rect:LHRectFromString([spriteProp objectForKey:@"UV"])];
	
	[self setSpriteProperties:ccsprite spriteProperties:spriteProp];
	
	return ccsprite;	
}
////////////////////////////////////////////////////////////////////////////////////
-(void) setSpriteProperties:(CCSprite*)ccsprite
			 spriteProperties:(NSDictionary*)spriteProp
{
	//convert position from LH to Cocos2d coordinates
	CGSize winSize = [[CCDirector sharedDirector] winSize];
	CGPoint position = LHPointFromString([spriteProp objectForKey:@"Position"]);
	position.y = winSize.height - position.y;
	
	[ccsprite setPosition:position];
	[ccsprite setRotation:[[spriteProp objectForKey:@"Angle"] floatValue]];
	[ccsprite setOpacity:255*[[spriteProp objectForKey:@"Opacity"] floatValue]];
	CGRect color = LHRectFromString([spriteProp objectForKey:@"Color"]);
	[ccsprite setColor:ccc3(255*color.origin.x, 255*color.origin.y, 255*color.size.width)];
	CGPoint scale = LHPointFromString([spriteProp objectForKey:@"Scale"]);
	[ccsprite setScaleX:scale.x];
	[ccsprite setScaleY:scale.y];
	[ccsprite setTag:[[spriteProp objectForKey:@"Tag"] intValue]];
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
-(void) setFixtureDefPropertiesFromDictionary:(NSDictionary*)spritePhysic 
									  fixture:(b2FixtureDef*)shapeDef
{
	shapeDef->density = [[spritePhysic objectForKey:@"Density"] floatValue];
	shapeDef->friction = [[spritePhysic objectForKey:@"Friction"] floatValue];
	shapeDef->restitution = [[spritePhysic objectForKey:@"Restitution"] floatValue];
	shapeDef->isSensor = [[spritePhysic objectForKey:@"IsSenzor"] boolValue];
	
	shapeDef->filter.categoryBits = [[spritePhysic objectForKey:@"Category"] intValue];
	shapeDef->filter.maskBits = [[spritePhysic objectForKey:@"Mask"] intValue];
	shapeDef->filter.groupIndex = [[spritePhysic objectForKey:@"Group"] intValue];
}
////////////////////////////////////////////////////////////////////////////////////
-(b2Body*) b2BodyFromDictionary:(NSDictionary*)spritePhysic
			   spriteProperties:(NSDictionary*)spriteProp
						   data:(CCSprite*)ccsprite 
						  world:(b2World*)_world
{
	b2BodyDef bodyDef;	
	
	b2Vec2 position = b2Vec2([ccsprite position].x/PTM_RATIO,[ccsprite position].y/PTM_RATIO);
	
	int bodyType = [[spritePhysic objectForKey:@"Type"] intValue];
	if(bodyType == 3) //in case the user wants to create a body with a sprite that has type as "NO_PHYSIC"
		bodyType = 2;
	bodyDef.type = (b2BodyType)bodyType;
	bodyDef.position.Set([ccsprite position].x/PTM_RATIO,[ccsprite position].y/PTM_RATIO);
	bodyDef.angle = DEGREES_TO_RADIANS(-1*[[spriteProp objectForKey:@"Angle"] floatValue]);
	
	bodyDef.userData = ccsprite;
	b2Body* body = _world->CreateBody(&bodyDef);
	
	body->SetFixedRotation([[spritePhysic objectForKey:@"FixedRot"] boolValue]);
	
	NSArray* fixtures = [spritePhysic objectForKey:@"ShapeFixtures"];
	CGPoint scale = LHPointFromString([spriteProp objectForKey:@"Scale"]); 
	CGPoint size = LHPointFromString([spriteProp objectForKey:@"Size"]);
	if(fixtures == nil || [fixtures count] == 0 || [[fixtures objectAtIndex:0] count] == 0)
	{
		b2PolygonShape shape;
		b2FixtureDef fixture;
		b2CircleShape circle;
		[self setFixtureDefPropertiesFromDictionary:spritePhysic fixture:&fixture];
		
		if([[spritePhysic objectForKey:@"IsCircle"] boolValue])
		{
			circle.m_radius = size.x*scale.x/2/PTM_RATIO;
			fixture.shape = &circle;
		}
		else
		{
			shape.SetAsBox(size.x*scale.x/PTM_RATIO/2, 
						   size.y*scale.y/PTM_RATIO/2);
			
			fixture.shape = &shape;
		}
		
		body->CreateFixture(&fixture);
	}
	else
	{
		for(NSArray* curFixture in fixtures)
		{
			int size = (int)[curFixture count];
			b2Vec2 *verts = new b2Vec2[size];
			b2PolygonShape shape;
			int i = 0;
			for(NSString* pointStr in curFixture)
			{
				CGPoint point = LHPointFromString(pointStr);
				verts[i] = b2Vec2(point.x*(scale.x)/PTM_RATIO, 
								  point.y*(scale.y)/PTM_RATIO);
				++i;
			}
			shape.Set(verts, size);		
			b2FixtureDef fixture;
			[self setFixtureDefPropertiesFromDictionary:spritePhysic fixture:&fixture];
			fixture.shape = &shape;
			body->CreateFixture(&fixture);
			delete verts;
		}
	}
	
	return body;
	
}
////////////////////////////////////////////////////////////////////////////////////
-(b2Joint*) b2JointFromDictionary:(NSDictionary*)joint world:(b2World*)world
{
	if(nil == joint)
		return 0;
	
	if(world == 0)
		return 0;
	
	b2Body* bodyA = (b2Body*)[[ccSpritesInScene objectForKey:[joint objectForKey:@"ObjectA"]] pointerValue];
	b2Body* bodyB = (b2Body*)[[ccSpritesInScene objectForKey:[joint objectForKey:@"ObjectB"]] pointerValue];
	
	CGPoint anchorA = LHPointFromString([joint objectForKey:@"AnchorA"]);
	CGPoint anchorB = LHPointFromString([joint objectForKey:@"AnchorB"]);
	bool collideConnected = [[joint objectForKey:@"CollideConnected"] boolValue];
	
	b2Vec2 posA, posB;
	
	if(![[joint objectForKey:@"CenterOfMass"] boolValue])
	{
		posA = b2Vec2(bodyA->GetWorldCenter().x + anchorA.x/PTM_RATIO, 
					  bodyA->GetWorldCenter().y + anchorA.y/PTM_RATIO);
		
		posB = b2Vec2(bodyB->GetWorldCenter().x + anchorB.x/PTM_RATIO, 
					  bodyB->GetWorldCenter().y + anchorB.y/PTM_RATIO);
	}
	else {		
		posA = b2Vec2(bodyA->GetWorldCenter().x, 
					  bodyA->GetWorldCenter().y);
		
		posB = b2Vec2(bodyB->GetWorldCenter().x, 
					  bodyB->GetWorldCenter().y);					
	}
	
	if(0 != bodyA && 0 != bodyB)
	{
		switch ([[joint objectForKey:@"Type"] intValue])
		{
			case LH_DISTANCE_JOINT:
			{
				//LHDistanceJoint* dJoint = (LHDistanceJoint*)joint;
				b2DistanceJointDef jointDef;
				
				jointDef.Initialize(bodyA, 
									bodyB, 
									posA,
									posB);
				
				jointDef.collideConnected = collideConnected;
				
				jointDef.frequencyHz = [[joint objectForKey:@"Frequency"] floatValue];
				jointDef.dampingRatio = [[joint objectForKey:@"Damping"] floatValue];
				
				if(0 != world)
				{
					return world->CreateJoint(&jointDef);
				}
			}	
				break;
				
			case LH_REVOLUTE_JOINT:
			{
				b2RevoluteJointDef jointDef;
				
				jointDef.Initialize(bodyA, bodyB, posA);
				
				jointDef.referenceAngle = DEGREES_TO_RADIANS([[joint objectForKey:@"RefAngle"] floatValue]);
				jointDef.lowerAngle = DEGREES_TO_RADIANS([[joint objectForKey:@"LowerAngle"] floatValue]);
				jointDef.upperAngle = DEGREES_TO_RADIANS([[joint objectForKey:@"UpperAngle"] floatValue]);
				jointDef.motorSpeed = [[joint objectForKey:@"MotorSpeed"] floatValue]; //Usually in radians per second. ?????
				jointDef.maxMotorTorque = [[joint objectForKey:@"MaxTorque"] floatValue]; //Usually in N-m.  ?????
				jointDef.enableLimit = [[joint objectForKey:@"EnableLimit"] boolValue];
				jointDef.enableMotor = [[joint objectForKey:@"EnableMotor"] boolValue];
				
				if(0 != world)
				{
					return world->CreateJoint(&jointDef);
				}
			}
				break;
				
			case LH_PRISMATIC_JOINT:
				break;
				
			case LH_PULLEY_JOINT:
				break;
				
			case LH_GEAR_JOINT:
				break;
				
			case LH_LINE_JOINT:
				break;
				
			case LH_WELD_JOINT:
				break;
				
			default:
				NSLog(@"Unknown joint type in LevelHelper file.");
				break;
		}
	}
	
	return 0;
}
////////////////////////////////////////////////////////////////////////////////////
-(void)loadLevelHelperSceneFile:(NSString*)levelFile inDirectory:(NSString*)subfolder imgSubfolder:(NSString*)imgFolder
{
	NSString *path = [[NSBundle mainBundle] pathForResource:levelFile ofType:@"plhs" inDirectory:subfolder]; 
	
	NSAssert(nil!=path, @"Invalid level file. Please add the LevelHelper scene file to Resource folder. Please do not add extension in the given string.");
	
	NSDictionary *dictionary = [NSDictionary dictionaryWithContentsOfFile:path];
	
	bool fileInCorrectFormat =	![[dictionary objectForKey:@"Author"] isEqualToString:@"Bogdan Vladu"] || 
	![[dictionary objectForKey:@"CreatedWith"] isEqualToString:@"LevelHelper"];
	
	NSAssert(true !=fileInCorrectFormat, @"This file was not created with LevelHelper or file is damaged.");
	
	////////////////////////LOAD WORLD BOUNDARIES//////////////////////////////////////////////
	if(nil != [dictionary objectForKey:@"WorldBoundaries"])
	{
		worldBoundaries = LHRectFromString([dictionary objectForKey:@"WorldBoundaries"]);
	}
	
	////////////////////////LOAD SPRITES////////////////////////////////////////////////////
    lhSprites = [[NSArray alloc] initWithArray:[dictionary objectForKey:@"SPRITES_INFO"]];
	
	///////////////////////////LOAD BATCH IMAGES////////////////////////////////////////////
	NSArray* batchImages = [dictionary objectForKey:@"LoadedImages"];
	for(NSDictionary* imageInfo in batchImages)
	{
		NSMutableDictionary* batchInfo = [[NSMutableDictionary alloc] init];
		
		CCSpriteBatchNode *batch = [CCSpriteBatchNode batchNodeWithFile:[imageInfo objectForKey:@"Image"]
															   capacity:BATCH_NODE_CAPACITY];	

		[batchInfo setObject:batch forKey:@"CCBatchNode"];
		[batchInfo setObject:[imageInfo objectForKey:@"OrderZ"] forKey:@"OrderZ"];
		
		
		[batchNodes setObject:batchInfo forKey:[imageInfo objectForKey:@"Image"]];
		[batchInfo release];
	}
	
	///////////////////////LOAD JOINTS//////////////////////////////////////////////////////////
	lhJoints = [[NSArray alloc] initWithArray:[dictionary objectForKey:@"JOINTS_INFO"]];
}
////////////////////////////////////////////////////////////////////////////////////
@end
